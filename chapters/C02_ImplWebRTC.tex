Das Projekt gliedert sich primär in zwei Teile: Das Brettspiel \glqq{}Mensch Ärgere Dich Nicht\grqq{}, und die unterliegende \acs{WebRTC}- und Netzwerkinfrastruktur. Die Projektstruktur selbst ist in Abbildung~ \ref{table:projectfiles} beschrieben. Auf die Spiel- und Netzwerkspezifischen Script-Dateien wird in deren jeweiligen Sektionen weiter eingegangen.

\begin{table}[ht]
\centering
\begin{tabularx}{\textwidth}{lX}
\toprule
Dateipfad&Beschreibung\\
\midrule
/*&Grundverzeichnis des Servers\\
/Server.js&Diese Datei ist die ausführbare Script-Datei des Webservers. Hier wird der express-Webserver erstellt, sowie die WebSocket Verbindungen via socket.io, und die Spielräume verwaltet.\\
/utils.js&Hilfsfunktionen zum Generieren von TURN-Passdaten, Raum-IDs und Peer-IDs.\\
/config.json&Server-Konfiguration.\\
/package.json&NPM-Konfiguration.\\
\midrule
/public/*&Öffentliche Dateien, welche über den Webserver abgerufen werden können.\\
/public/index.html&HTML-Datei der Seite, auf welcher ein Spieler einen Raum erstellen oder beitreten kann.\\
/public/game.html&HTML-Datei der Spiel-Seite.\\
\midrule
/public/resources/*&CSS, Bild- und Scriptressourcen.\\
/public/resources/script/index.js&JS-Datei der Index-HTML-Seite.\\
/public/resources/script/game.js&JS-Datei der Spiel-HTML-Seite.\\
\midrule
/public/resources/script/network/*&Netzwerkspezifische Script-Dateien\\
/public/resources/script/game/*&Spielspezifische Script-Dateien\\
\bottomrule
\end{tabularx}
\caption{Struktur des Projektes.}
\label{table:projectfiles}
\end{table}

\section{Bereitstellungsplattform}
Zur Bereitstellung der in diesem Kapitel beschriebenen Server wird eine Virtuelle Maschine auf der Azure-Plattform genutzt. Azure ist eine Cloud-Computing-Plattform von Microsoft, welche sowohl Software-, Platform- und Infrastructure-As-A-Service (SaaS, PaaS, IaaS) anbietet.\par

Azure ermöglicht das Erstellen von Rechnenressourcen in der Cloud, in der Form von Virtuellen Maschinen. Dabei existieren verschiedene Ausführungen von Virtuellen Maschinen, welche sich beim dem eingesetzten Betriebssystem, sowie der \glqq{}Größe\grqq{} anpassen lassen. Die Größe gibt dabei den Arbeitsspeicher, die Anzahl der (virtuellen) Prozessorkerne, sowie die Art und Anzahl der Datenträger vor.\par

Für die prototypische Bereitstellung der Server wurde eine \acf{VM} der Größe \glqq{}B1s\grqq{} erstellt. Die B-Reihe ist dabei auf geringe Arbeitsbelastung ausgelegt. Eine B1s-VM verfügt über einen virtuellen Prozessorkern, ein Gigabyte Arbeitsspeicher und zwei Datenträger mit maximal 4 Gigabyte an temporärem Speicher. Für eine prototypische Bereitstellung, bei welcher nicht viel Serverlast zu erwarten ist, ist eine B1s-VM ausreichend.\par

Als Betriebssystem eignet sich praktisch jedes Betriebssystem, welches das bereitstellen von Servern ermöglicht. Azure bietet dabei viele verschiedene Linux-Distributionen und Windows-Server-Images. Als Betriebssystem wurde hier Ubuntu 18.04 LTS (Long-Term-Support, dt. Langzeitsupport) gewählt, primär da das Packet des genutzen STUN- und TURN-Servers in den Repositories von Ubuntu 18.04+ enthalten ist, und so einfach über den Packetmanager \textit{apt} installiert werden kann.\par

Der \acs{VM} muss zusätzlich eine öffentliche IP-Adresse zugewiesen werden, damit die auf der Maschine laufenden Server von Außen erreichbar sind. Für diese IP-Adresse lässt sich zudem ein Domain-Name in der Form
\lstset{style=STYLE_COMMAND_LINE_ARGUMENT_SINGLE_LINE}
\begin{lstlisting}[belowskip=-0.8 \baselineskip]
<DNS-Name>.<Region der VM>.cloudapp.azure.com
\end{lstlisting}
festlegen. Der für diese VM gewählte Domain-Name lautet somit:
\lstset{style=STYLE_COMMAND_LINE_ARGUMENT_SINGLE_LINE}
\begin{lstlisting}[belowskip=-0.8 \baselineskip]
ba-webrtc.westeurope.cloudapp.azure.com
\end{lstlisting}

\section{Implementation der Netzwerkinfrastruktur}
Die Netzwerkinfrastruktur ist in drei Teile geteilt: Der Webserver, welcher die Seiten bereitstellt und als Signalisierungskanal dient, die Clientseitige WebRTC-Implementation und die \acs{STUN}- und \acs{TURN}-Server. Zusammen bilden diese drei Komponenten das \glqq{}WebRTC-Dreieck\grqq{}.

\subsection{Implementation des Webservers}
Um das Verbinden von Peers via WebRTC zu ermöglichen, muss vorerst ein Signalisierungskanal existieren, welcher Nachrichten zwischen Peers weiterleiten kann. Die Art des Signal-Kanals ist dabei nicht vom WebRTC-Standard vorgegeben. Für die Implementierung wurde daher ein Signal-Server geschaffen, welcher WebSockets zur Datenübertragung nutzt. Der Server dient zusätzlich als Webserver, welcher das Brettspiel als Webanwendung bereitstellt, und die Nutzer in \glqq{}Räume\grqq{} unterteilt, damit mehr als ein Spiel zur gleichen Zeit stattfinden kann.\par

\subsubsection{Erstellen des Node-Servers}
Um einen Node-Server zu erstellen, muss der Node-Package-Manager über den Kommandozeilenbefehl

\lstset{style=STYLE_COMMAND_LINE_ARGUMENT_SINGLE_LINE}
\begin{lstlisting}[belowskip=-0.8 \baselineskip]
$ npm init
\end{lstlisting}

initialisiert werden. Dieser Befehl erstellt die \glqq{}package.json\grqq{}-Datei im momentanen Arbeitsordner. Zudem müssen die benötigten Packete via

\lstset{style=STYLE_COMMAND_LINE_ARGUMENT_SINGLE_LINE}
\begin{lstlisting}[belowskip=-0.8 \baselineskip]
$ npm install socket.io
$ npm install express
\end{lstlisting}

heruntergeladen werden. Daraufhin können diese Packete über die $require$-Funktion in ein Script eingebunden werden.

\subsubsection{express Web-Server}
Zur Erstellung des Webservers wird das \glqq{}express\grqq{}-Packet verwendet. Der Quellcode befindet sich in der \glqq{}Server.js\grqq{}-Datei, und ist in Abbildung~\ref{lst:express} abgebildet.

\vspace{11pt}
\lstset{language=js, style=STYLE_CODE_JS}
\begin{minipage}{\textwidth}
\begin{singlespace}
\begin{lstlisting}[caption={express Server -- Server.js}, captionpos=b, label={lst:express}]
const express = require('express');
const config = require('./config.json');

const app = express();
const server = require('http').Server(app);

app.use(express.static('public'));

app.get('/', (req, res) => {
  res.status(200);
  res.sendFile(`${__dirname}${config.server.indexPage}`);
});

app.get('/game/*/', (req, res) => {
  res.status(200);
  res.sendFile(`${__dirname}${config.server.gamePage}`);
});

server.listen(config.server.listeningPort);
\end{lstlisting}
\end{singlespace}
\end{minipage}

Zuerst muss eine express-Anwendung über die $express()$-Funktion erstellt werden. Da für die Nutzung von socket.io allerdings ein \acs{HTTP}-Serverobjekt nötig ist, wird dieses in Zeile 5 erstellt. Dabei wird die express-Anwendung als Parameter bei der Servererstellung mitgegeben. Die express-Anwendung nutzt nun diesen \acs{HTTP}-Server für die Webserver-Funktionalität.\par

Da die \acs{HTML}-Dateien die notwendingen Scripts aus anderen Dateien importieren, müssen diese via \acs{URL} vom Webserver abrufbar sein. Die Funktion $app.use$ erlaubt es, Dateien via \acs{URL} öffentlich bereitzustellen. In Zeile 7 wird daher der Inhalt des \glqq{}public\grqq{}-Ordners statisch zur Verfügung gestellt.\par

Des Weiteren werden in Zeile 9 und 14 die Pfade definiert, auf welchen die \acs{HTML}-Dateien abrufbar sind. Ruft ein Nutzer die Basis-\acs{URL} des Servers auf, so sendet der Server die \glqq{}index.html\grqq{}-Datei. Ruft ein Nutzer den Pfad \grqq{}<Basis-Server-URL>/game/<Raum-ID>/\grqq{} auf, so wird dieser auf die Raum-Seite (\glqq{}room.html\grqq{}) verwiesen. Dies bewirkt, dass ein Nutzer direkt über eine \acs{URL} einem Spiel beitreten kann, und nicht über die Index-Seite beitreten muss. Die Dateipfade sind in der Server-Konfigurationsdatei definiert.

Zuletzt muss in Zeile 19 noch der Port definiert werden, über welchen der Server von außen ansprechbar sein soll. Dieser ist ebenfalls via der Konfigurationsdatei definierbar. Wichtig ist, dass dieser Port des Servers, auf welchem der Webserver läuft, weitergeleitet ist [siehe: Aufsetzen der Server (oder so, // todo!!!)].

\subsubsection{socket.io}

\vspace{11pt}
\lstset{language=js, style=STYLE_CODE_JS}
\begin{minipage}{\textwidth}
\begin{singlespace}
\begin{lstlisting}[caption={Initialisierung des socket.io Servers -- Server.js}, captionpos=b, label={lst:socketioserver}]
[...]
const server = require('http').Server(app);
const io = require('socket.io')(server);
[...]
io.sockets.on('connection', (socket) => {
  [...]
}
\end{lstlisting}
\end{singlespace}
\end{minipage}


\vspace{11pt}
\lstset{language=js, style=STYLE_CODE_JS}
\begin{minipage}{\textwidth}
\begin{singlespace}
\begin{lstlisting}[caption={Clientseitiger Verbindungsaufbau -- game.js}, captionpos=b, label={lst:socketioclient}]
[...]
$(document).on('DOMContentLoaded', () => {
  const socket = io('http://localhost:1234');
  const roomID = window.location.pathname.split('/')[2];
  socket.on('connect', () => {
    [...]
  );
  [...]
)
\end{lstlisting}
\end{singlespace}
\end{minipage}


\subsection{Raum-Management}
Das Spiel \glqq{}Mensch Ärgere Dich Nicht\grqq{} kann maximal von vier Spielern gespielt werden. Damit mehr als ein Spiel gleichzeitig gespielt werden kann, müssen Spieler in \glqq{}Räume\grqq{} unterteilt werden. Ein Raum besitzt dabei eine Liste an bis zu vier Sets an Spielerdaten, eine Raum-ID und eine Host-ID. Bei der Host-ID handelt es sich um die Socket-ID des Spielers, welcher den Raum zuerst betritt. Dieser hat als einziger Spieler die Befugnis, weitere Spieler aus dem Raum zu entfernen. Spielerdaten enthalten jeweils die Peer-ID eines Spielers, einen Namen und die Spielfarbe des Spielers.

\subsubsection{Erstellen eines Raums}

\vspace{11pt}
\lstset{language=js, style=STYLE_CODE_JS}
\begin{singlespace}
\begin{lstlisting}[caption={Event zum Erstellen eines Raums -- Server.js}, captionpos=b, label={lst:imamakedaroom}]
const utils = require('./utils.js');
[...]
const rooms = {}
const playerSockets = {}

io.sockets.on('connection', (socket) => {
  socket.on('game-room-create', () => {
    const id = utils.generateRoomID(rooms);
    rooms[id] = {
      id : id, // easier to identify room by player
      players : [],
      started : false,
      host : null
    };
    [...]	
    socket.emit('game-room-created', id);
  });
  [...]
}
\end{lstlisting}
\end{singlespace}

Erstellt ein Nutzer einen Raum, so sendet dieser das \textit{game-room-create}-Event zum Server (vgl. Abbildung~\ref{lst:imamakedaroom}). Der Server generiert eine vierstellige Zeichenkette, welche als Raum-ID dient. Mit dieser wird in Zeile 10 ein Raum-Objekt erzeugt, welches die zuvor beschriebenen Daten enthält. Zudem speichert das Raum-Objekt, ob das Spiel in diesem Raum bereits gestartet ist. Ist der Raum erstellt, so wird ein Event an den erstellenden Client zurückgeschickt, um diesem mitzuteilen, dass der Raum nun beitretbar ist.\par

\subsubsection{Beitritt eines Raums}

Das Betreten eines Raums ist über das \textit{game-room-join}-Event geregelt. Versucht ein Nutzer einem Raum beizutreten, so sendet dieser das Event an den Server (vgl. Abbildung~\ref{lst:join}). Falls der Raum noch keinen Host-Spieler besitzt, so wird der erste Beitretende Spieler in Zeile 17 zum Host ernannt. Bei erfolgreichem Beitritt erhält der Nutzer, wie in Zeile 20 zu sehen, das \textit{game-room-joined}-Event zurück, welches sämtliche, zum Verbindungsaufbau mit den anderen Spielern des Raums, benötigten Daten enthält. Dazu gehören das Array der weiteren Spieler im Raum, die eigene Peer-ID und die Zugangsdaten zu den \acs{STUN}- und \acs{TURN}-Servern. Zusätzlich wird dem Nutzer mitgeteilt, ob dieser der Host des Raums ist. Zudem werden in Zeile 27--29 alle weiteren Spieler des Raums benachrichtigt, dass ein weiterer Spieler beigetreten ist.\par

In deb Spielregeln von \glqq{}Mensch Ärgere Dich Nicht\grqq{} ist geregelt, dass beim Spielen mit zwei Spielern die Farben Gelb und Rot gewählt werden sollen, damit die Spieler gegenüberstehende Startfelder haben. Daher werden die Spieler beim Betreten eines Raums nicht nach aufsteigender Reihenfolge in das Spieler-Array eingefügt, sondern nach der in Zeile 1 definierten Reihenfolge [0, 2, 1, 3]. Ab Zeile 8 wird dieses Array durchlaufen. Ist ein Array-Index nicht definiert, so wird der neu beigetretene Spieler an diese Stelle des Spieler-Arrays gesetzt.\par

\begin{table}[ht]
\centering
\begin{tabular}[t]{lc}
\toprule
Spieler-Index&Farbe im Spiel\\
\midrule
0&Gelb\\
1&Grün\\
2&Rot\\
3&Schwarz\\
\bottomrule
\end{tabular}
\caption{Spielerfarben.}
\label{table:playercolors}
\end{table}

Dazu wird in Zeile 10 zuerst eine Peer-ID generiert, welche zu Signalisierungszwecken genutzt wird. Die \glqq{}Farbe\grqq{} des Spielers ist dabei der Index des Spielers im Spieler-Array (vgl. Tabelle~\ref{table:playercolors}).\par

\vspace{11pt}
\lstset{language=js, style=STYLE_CODE_JS}
\begin{singlespace}
\begin{lstlisting}[caption={Event zum Betreten eines Raums -- Server.js}, captionpos=b, label={lst:join}]
const PLAYER_SLOT_PRIORITY = [0, 2, 1, 3];
[...]
io.sockets.on('connection', (socket) => {
  [...]
  socket.on('game-room-join', (roomID) => {
    const room = rooms[roomID];
    [...]
    for (let i = 0; i < 4; i++) {
      if (!room.players[PLAYER_SLOT_PRIORITY[i]]) {
        const peerID = utils.uuid4();
        const color = PLAYER_SLOT_PRIORITY[i];

        playerSockets[peerID] = socket.id;
        room.players[color] = {peerID : peerID, color : color};

        if (!room.host) {
          room.host = socket.id;
        }

        socket.emit('game-room-joined', 
          room.players, 
          peerID, 
          utils.generateTURNCredentials(socket.id), 
          room.host === socket.id
        );

        room.players.forEach((player) => {
          socket.to(playerSockets[player.peerID]).emit('game-room-client-joining', peerID, color)
        });
        break;
      }
    }
  });
  [...]
}
\end{lstlisting}
\end{singlespace}

\subsubsection{Weitere Raumspezifische Events}
\begin{table}[ht]
\centering
\begin{tabularx}{\textwidth}{lX}
\toprule
Event&Beschreibung\\

\midrule
game-room-join-failed&Wird vom Server zurückgegeben, wenn der Raum, dem der Client beitreten will, nicht verfügbar oder voll ist.\\
game-room-client-leaving&Wird vom Server an alle Spieler eines Raums gesendet, wenn ein Spieler den Raum verlässt.\\
game-room-host-migration&Ausgelöst vom Server, wenn der Host eines Raums diesen verlässt. Die Socket-ID des neuen als Host agierenden Spielers wird als Parameter dieses Events mitgegeben.\\
\bottomrule

\end{tabularx}
\caption{Weitere Raumspezifische Events.}
\label{table:otherevents}
\end{table}

Des weiteren existieren Events, welche das Verlassen von Räumen, entweder durch den Nutzer manuell ausgelöst, oder bedingt durch Verbindungsverlust, behandeln. Verlässt ein Spieler einen Raum, so erhalten alle verbliebenen Spieler ein Event darüber. Verlässt der Host-Spieler den Raum, so geht der Host-Status auf den nächsten Spieler im Spieler-Array über. Verlässt der letzte verbleibende Spieler den Raum, so wird dieser entfernt. Diese Events sind in Tabelle~\ref{table:otherevents} zusammengefasst.\par

\subsection{Signalisierungskanal}
Das Weiterleiten von Signalisierungsnachrichten zwischen Peers wird über die gleiche socket.io-Verbindung geregelt, wie die Raumverwaltung. Dazu wird das \textit{signal}-Event verwendet. Zur Signalisierung muss dabei immer die ID des Raums angegeben werden, in welchem die Signal-Nachricht weitergeleitet werden soll. Zudem muss die Peer-ID des Ziel-Peers angegeben werden. Existieren Raum und Peer, so wird das \textit{signal}-Event an diesen weitergeleitet. Abbildung~\ref{lst:signalserver} zeigt die Serverseitige Rückruffunktion des \textit{signal}-Events.

\vspace{11pt}
\lstset{language=js, style=STYLE_CODE_JS}
\begin{singlespace}
\begin{lstlisting}[caption={Event zum Weiterleiten eines Signals -- Server.js}, captionpos=b, label={lst:signalserver}]
io.sockets.on('connection', (socket) => {
  [...]
  socket.on('signal', (roomID, targetID, e) => {
    const room = rooms[roomID];

    if (room) {
      const target = room.players.find((player) => && player.peerID === targetID);
      if (target) {
        socket.to(playerSockets[target.peerID]).emit('signal', e);
      }
    }
  });
  [...]
}
\end{lstlisting}
\end{singlespace}

\section{Implementation der Peer-To-Peer Funktionalität}



\lstset{language=js, style=STYLE_CODE_JS}
\begin{lstlisting}[caption={Javascript LstListing Test}, captionpos=b, label={lst:candidate}]
Peer.prototype.connect = function(remotePeerId) {
  const connection = this._createConnection(remotePeerId, true);
  this.connections[remotePeerId] = connection;

  connection.createOffer().then((offer) => {
    connection.setLocalDescription(offer).then(() => this.sendSignal(
      this._createSignal('offer', connection.localDescription, remotePeerId)
    ));
  });
}
\end{lstlisting}

\begin{lstlisting}[caption={Javascript LstListing Test}, captionpos=b, label={lst:candidate}]
Peer.prototype._createConnection = function(remotePeerId) {
  const connection = new RTCPeerConnection(this.rtcConfiguration);
  connection.dc = {}; // list of data channels belonging to this connection

  this.channels.forEach((options, i) => {
    const channel = connection.createDataChannel(options.label, {
      negotiated : true,
      id : i,
      ordered : options.ordered || true,
      maxRetransmits : options.maxRetransmits || null,
      maxPacketLifeTime : options.maxPacketLifeTime || null,
    });
    channel.onmessage = (e) => this._receiveMessage(e);

    connection.dc[channel.label] = channel;
  });

  connection.onicecandidate = (e) => {
    this.sendSignal(this._createSignal('ice-candidate', e.candidate, remotePeerId));
  }

  return connection;
}
\end{lstlisting}

\begin{lstlisting}[caption={Javascript LstListing Test}, captionpos=b, label={lst:candidate}]
Peer.prototype.onsignal = function(e) {
  switch(e.type) {
    case 'offer':
      const connection = this._createConnection(e.src);
      this.connections[e.src] = connection;

      connection.setRemoteDescription(e.data).then(() => {
        connection.createAnswer().then((answer) => {
          connection.setLocalDescription(answer).then(() => {
            this.sendSignal(this._createSignal('answer', connection.localDescription, e.src));
          })
        });
      });
      break;
    case 'answer':
      this.connections[e.src].setRemoteDescription(e.data).then();
      break;
    case 'ice-candidate':
      this.connections[e.src].addIceCandidate(e.data).then();
      break;
  }
}
\end{lstlisting}

\section{Aufsetzen und Konfiguration eines STUN und TURN Servers}
Zum Verbindungsaufbau zwischen Peers müssen \acs{STUN}- und \acs{TURN}-Server existieren.
