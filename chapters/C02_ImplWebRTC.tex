Das Projekt gliedert sich primär in zwei Teile: Das Brettspiel \glqq{}Mensch Ärgere Dich Nicht\grqq{}, und die unterliegende \acs{WebRTC}- und Netzwerkinfrastruktur. Die Projektstruktur selbst ist in Abbildung~ \ref{table:projectfiles} beschrieben. Auf die Spiel- und Netzwerkspezifischen Script-Dateien wird in deren jeweiligen Sektionen weiter eingegangen.

\begin{table}[ht]
\centering
\begin{tabularx}{\textwidth}{lX}
\toprule
Dateipfad&Beschreibung\\
\midrule
/*&Grundverzeichnis des Servers\\
/Server.js&Diese Datei ist die ausführbare Script-Datei des Webservers. Hier wird der express-Webserver erstellt, sowie die WebSocket Verbindungen via socket.io, und die Spielräume verwaltet.\\
/utils.js&Hilfsfunktionen zum Generieren von TURN-Passdaten, Raum-IDs und Peer-IDs.\\
/config.json&Server-Konfiguration.\\
/package.json&NPM-Konfiguration.\\
\midrule
/public/*&Öffentliche Dateien, welche über den Webserver abgerufen werden können.\\
/public/index.html&HTML-Datei der Seite, auf welcher ein Spieler einen Raum erstellen oder beitreten kann.\\
/public/game.html&HTML-Datei der Spiel-Seite.\\
\midrule
/public/resources/*&CSS, Bild- und Scriptressourcen.\\
/public/resources/script/index.js&JS-Datei der Index-HTML-Seite.\\
/public/resources/script/game.js&JS-Datei der Spiel-HTML-Seite.\\
\midrule
/public/resources/script/network/*&Netzwerkspezifische Script-Dateien\\
/public/resources/script/game/*&Spielspezifische Script-Dateien\\
\bottomrule
\end{tabularx}
\caption{Vergleich von \acs{TCP} und \acs{UDP} mit \acs{SCTP}.}
\label{table:projectfiles}
\end{table}

\section{Implementation der WebRTC-Infrastruktur}
Die Netzwerkinfrastruktur ist in drei Teile geteilt: Der Webserver, welcher die Seiten bereitstellt und als Signalisierungskanal dient, die Clientseitige WebRTC-Implementation und die \acs{STUN}- und \acs{TURN}-Server. Zusammen bilden diese drei Komponenten das \glqq{}WebRTC-Dreieck\grqq{}.

\subsection{Implementation des Webservers}
Um das Verbinden von Peers via WebRTC zu ermöglichen, muss vorerst ein Signalisierungskanal existieren, welcher Nachrichten zwischen Peers weiterleiten kann. Die Art des Signal-Kanals ist dabei nicht vom WebRTC-Standard vorgegeben. Für die Implementierung wurde daher ein Signal-Server geschaffen, welcher WebSockets zur Datenübertragung nutzt. Der Server dient zusätzlich als Webserver, welcher das Brettspiel als Webanwendung bereitstellt, und die Nutzer in \glqq{}Räume\grqq{} unterteilt, damit mehr als ein Spiel zur gleichen Zeit stattfinden kann.\par

\subsubsection{Erstellen des Node-Servers}
Um einen Node-Server zu erstellen, muss der Node-Package-Manager über den Kommandozeilenbefehl

\lstset{style=STYLE_COMMAND_LINE_ARGUMENT_SINGLE_LINE}
\begin{lstlisting}[belowskip=-0.8 \baselineskip]
$ npm init
\end{lstlisting}

initialisiert werden. Dieser Befehl erstellt die \glqq{}package.json\grqq{}-Datei im momentanen Arbeitsordner. Zudem müssen die benötigten Packete via

\lstset{style=STYLE_COMMAND_LINE_ARGUMENT_SINGLE_LINE}
\begin{lstlisting}[belowskip=-0.8 \baselineskip]
$ npm install socket.io
$ npm install express
\end{lstlisting}

heruntergeladen werden. Daraufhin können diese Packete über die $require$-Funktion in ein Script eingebunden werden.

\subsubsection{express Web-Server}
Zur Erstellung des Webservers wird das \glqq{}express\grqq{}-Packet verwendet. Der Quellcode befindet sich in der \glqq{}Server.js\grqq{}-Datei, und ist in Abbildung~\ref{lst:express} abgebildet.

\vspace{11pt}
\lstset{language=js, style=STYLE_CODE_JS}
\begin{lstlisting}[caption={express Server -- Server.js}, captionpos=b, label={lst:express}]
const express = require('express');
const config = require('./config.json');

const app = express();
const server = require('http').Server(app);

app.use(express.static('public'));

app.get('/', (req, res) => {
  res.status(200);
  res.sendFile(`${__dirname}${config.server.indexPage}`);
});

app.get('/game/*/', (req, res) => {
  res.status(200);
  res.sendFile(`${__dirname}${config.server.gamePage}`);
});

server.listen(config.server.listeningPort);
\end{lstlisting}

Zuerst muss eine express-Anwendung über die $express()$-Funktion erstellt werden. Da für die Nutzung von socket.io allerdings ein \acs{HTTP}-Serverobjekt nötig ist, wird dieses in Zeile 5 erstellt. Dabei wird die express-Anwendung als Parameter bei der Servererstellung mitgegeben. Die express-Anwendung nutzt nun diesen \acs{HTTP}-Server für die Webserver-Funktionalität.\par

Da die \acs{HTML}-Dateien die notwendingen Scripts aus anderen Dateien importieren, müssen diese via \acs{URL} vom Webserver abrufbar sein. Die Funktion $app.use$ erlaubt es, Dateien via \acs{URL} öffentlich bereitzustellen. In Zeile 7 wird daher der Inhalt des \glqq{}public\grqq{}-Ordners statisch zur Verfügung gestellt.\par

Des Weiteren werden in Zeile 9 und 14 die Pfade definiert, auf welchen die \acs{HTML}-Dateien abrufbar sind. Ruft ein Nutzer die Basis-\acs{URL} des Servers auf, so sendet der Server die \glqq{}index.html\grqq{}-Datei. Ruft ein Nutzer den Pfad \grqq{}<Basis-Server-URL>/game/<Raum-ID>/\grqq{} auf, so wird dieser auf die Raum-Seite (\glqq{}room.html\grqq{}) verwiesen. Dies bewirkt, dass ein Nutzer direkt über eine \acs{URL} einem Spiel beitreten kann, und nicht über die Index-Seite beitreten muss. Die Dateipfade sind in der Server-Konfigurationsdatei definiert.

Zuletzt muss in Zeile 19 noch der Port definiert werden, über welchen der Server von außen ansprechbar sein soll. Dieser ist ebenfalls via der Konfigurationsdatei definierbar. Wichtig ist, dass dieser Port des Servers, auf welchem der Webserver läuft, weitergeleitet ist [siehe: Aufsetzen der Server (oder so, // todo!!!)].

\subsubsection{socket.io}

\vspace{11pt}
\lstset{language=js, style=STYLE_CODE_JS}
\begin{lstlisting}[caption={Initialisierung des socket.io Servers -- Server.js}, captionpos=b, label={lst:candidate}]
[...]
const server = require('http').Server(app);
const io = require('socket.io')(server);
[...]
io.sockets.on('connection', (socket) => {
  [...]
}
\end{lstlisting}

\subsection{Raum-Management}
Das Spiel \glqq{}Mensch Ärgere Dich Nicht\grqq{} kann maximal von vier Spielern gespielt werden. Damit mehr als ein Spiel gleichzeitig gespielt werden kann, müssen Spieler in \glqq{}Räume\grqq{} unterteilt werden. Ein Raum besitzt dabei eine Liste an bis zu vier Sets an Spielerdaten, eine Raum-ID und eine Host-ID. Bei der Host-ID handelt es sich um die Socket-ID des Spielers, welcher den Raum zuerst betritt. Dieser hat als einziger Spieler die Befugnis, weitere Spieler aus dem Raum zu entfernen. Spielerdaten enthalten jeweils die Peer-ID eines Spielers, einen Namen und die Spielfarbe des Spielers.

\vspace{11pt}
\lstset{language=js, style=STYLE_CODE_JS}
\begin{lstlisting}[caption={Event zum Erstellen eines Raums -- Server.js}, captionpos=b, label={lst:imamakedaroom}]
const utils = require('./utils.js');
[...]

const rooms = {}
const playerSockets = {}

io.sockets.on('connection', (socket) => {
  socket.on('game-room-create', () => {
    const id = utils.generateRoomID(rooms);
    rooms[id] = {
      id : id, // easier to identify room by player
      players : [],
      started : false,
      host : null
    };
    [...]	
    socket.emit('game-room-created', id);
  });
  [...]
}
\end{lstlisting}

Erstellt ein Nutzer einen Raum, so sendet dieser das \textit{game-room-create}-Event zum Server (vgl. Abbildung~\ref{lst:imamakedaroom}). Der Server generiert eine vierstellige Zeichenkette, welche als Raum-ID dient. Mit dieser wird in Zeile 10 ein Raum-Objekt erzeugt, welches die zuvor beschriebenen Daten enthält. Zudem speichert das Raum-Objekt, ob das Spiel in diesem Raum bereits gestartet ist. Ist der Raum erstellt, so wird ein Event an den erstellenden Client zurückgeschickt, um diesem mitzuteilen, dass der Raum nun beitretbar ist.\par

Das Betreten eines Raums ist über das \textit{game-room-join}-Event geregelt. Versucht ein Nutzer einem Raum beizutreten, so sendet dieser das Event an den Server (vgl. Abbildung~\ref{lst:join}). Falls der Raum noch keinen Host-Spieler besitzt, so wird der erste Beitretende Spieler in Zeile 17 zum Host ernannt. Bei erfolgreichem Beitritt erhält der Nutzer, wie in Zeile 20 zu sehen, das \textit{game-room-joined}-Event zurück, welches sämtliche, zum Verbindungsaufbau mit den anderen Spielern des Raums, benötigten Daten enthält. Dazu gehören das Array der weiteren Spieler im Raum, die eigene Peer-ID und die Zugangsdaten zu den \acs{STUN}- und \acs{TURN}-Servern. Zusätzlich wird dem Nutzer mitgeteilt, ob dieser der Host des Raums ist. Zudem werden in Zeile 27--29 alle weiteren Spieler des Raums benachrichtigt, dass ein weiterer Spieler beigetreten ist.\par

Die Spielregeln von \glqq{}Mensch Ärgere Dich Nicht\grqq{} besagen, dass beim Spielen mit zwei Spielern, die Farben Gelb und Rot gewählt werden sollen, damit die Spieler gegenüberstehende Startfelder haben. Daher werden die Spieler beim Betreten eines Raums nicht nach aufsteigender Reihenfolge in das Spieler-Array eingefügt, sondern nach der in Zeile 1 definierten Reihenfolge [0, 2, 1, 3]. Ab Zeile 8 wird dieses Array durchlaufen. Ist ein Array-Index nicht definiert, so wird der neu beigetretene Spieler an diese Stelle des Spieler-Arrays gesetzt.\par

\begin{table}[ht]
\centering
\begin{tabular}[t]{lc}
\toprule
Spieler-Index&Farbe im Spiel\\
\midrule
0&Gelb\\
1&Grün\\
2&Rot\\
3&Schwarz\\
\bottomrule
\end{tabular}
\caption{Spielerfarben.}
\label{table:playercolors}
\end{table}

Dazu wird in Zeile 10 zuerst eine Peer-ID generiert, welche zu Signalisierungszwecken genutzt wird. Die \glqq{}Farbe\grqq{} des Spielers ist dabei der Index des Spielers im Spieler-Array (vgl. Tabelle~\ref{table:playercolors}).\par

\vspace{11pt}
\lstset{language=js, style=STYLE_CODE_JS}
\begin{lstlisting}[caption={Event zum Betreten eines Raums -- Server.js}, captionpos=b, label={lst:join}]
const PLAYER_SLOT_PRIORITY = [0, 2, 1, 3];
[...]
io.sockets.on('connection', (socket) => {
  [...]
  socket.on('game-room-join', (roomID) => {
    const room = rooms[roomID];
    [...]
    for (let i = 0; i < 4; i++) {
      if (!room.players[PLAYER_SLOT_PRIORITY[i]]) {
        const peerID = utils.uuid4();
        const color = PLAYER_SLOT_PRIORITY[i];

        playerSockets[peerID] = socket.id;
        room.players[color] = {peerID : peerID, color : color};

        if (!room.host) {
          room.host = socket.id;
        }

        socket.emit('game-room-joined', 
          room.players, 
          peerID, 
          utils.generateTURNCredentials(socket.id), 
          room.host === socket.id
        );

        room.players.forEach((player) => {
          socket.to(playerSockets[player.peerID]).emit('game-room-client-joining', peerID, color)
        });
        break;
      }
    }
  });
  [...]
}
\end{lstlisting}

\subsection{Signalisierung}
Blabla blalala bla Blabla blalala bla Blabla blalala bla Blabla blalala bla Blabla blalala bla Blabla blalala bla Blabla blalala bla Blabla blalala bla Blabla blalala bla Blabla blalala bla Blabla blalala bla Blabla blalala bla Blabla blalala bla Blabla blalala bla Blabla blalala bla Blabla blalala bla. Ich sollte mir echt mal das lipsum package runterladen...

\vspace{11pt}
\lstset{language=js, style=STYLE_CODE_JS}
\begin{lstlisting}[caption={Event zum Weiterleiten eines Signals -- Server.js}, captionpos=b, label={lst:imamakedaroom}]
[...]
io.sockets.on('connection', (socket) => {
  [...]
  socket.on('signal', (roomID, target, e) => {
    const room = rooms[roomID];

    if (room) {
      const target = room.players.find((players) => players.peerID === e.target)
      if (target) {
        socket.to(playerSockets[target.peerID]).emit('signal', e);
      }
    }
  });
  [...]
}
\end{lstlisting}


\section{Implementation der Peer-To-Peer Funktionalität}



\lstset{language=js, style=STYLE_CODE_JS}
\begin{lstlisting}[caption={Javascript LstListing Test}, captionpos=b, label={lst:candidate}]
Peer.prototype.connect = function(remotePeerId) {
  const connection = this._createConnection(remotePeerId, true);
  this.connections[remotePeerId] = connection;

  connection.createOffer().then((offer) => {
    connection.setLocalDescription(offer).then(() => this.sendSignal(
      this._createSignal('offer', connection.localDescription, remotePeerId)
    ));
  });
}
\end{lstlisting}

\begin{lstlisting}[caption={Javascript LstListing Test}, captionpos=b, label={lst:candidate}]
Peer.prototype._createConnection = function(remotePeerId) {
  const connection = new RTCPeerConnection(this.rtcConfiguration);
  connection.dc = {}; // list of data channels belonging to this connection

  this.channels.forEach((options, i) => {
    const channel = connection.createDataChannel(options.label, {
      negotiated : true,
      id : i,
      ordered : options.ordered || true,
      maxRetransmits : options.maxRetransmits || null,
      maxPacketLifeTime : options.maxPacketLifeTime || null,
    });
    channel.onmessage = (e) => this._receiveMessage(e);

    connection.dc[channel.label] = channel;
  });

  connection.onicecandidate = (e) => {
    this.sendSignal(this._createSignal('ice-candidate', e.candidate, remotePeerId));
  }

  return connection;
}
\end{lstlisting}

\begin{lstlisting}[caption={Javascript LstListing Test}, captionpos=b, label={lst:candidate}]
Peer.prototype.onsignal = function(e) {
  switch(e.type) {
    case 'offer':
      const connection = this._createConnection(e.src);
      this.connections[e.src] = connection;

      connection.setRemoteDescription(e.data).then(() => {
        connection.createAnswer().then((answer) => {
          connection.setLocalDescription(answer).then(() => {
            this.sendSignal(this._createSignal('answer', connection.localDescription, e.src));
          })
        });
      });
      break;
    case 'answer':
      this.connections[e.src].setRemoteDescription(e.data).then();
      break;
    case 'ice-candidate':
      this.connections[e.src].addIceCandidate(e.data).then();
      break;
  }
}
\end{lstlisting}

\section{Aufsetzen und Konfiguration eines STUN und TURN Servers}